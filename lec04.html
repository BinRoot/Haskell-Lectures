<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Introduction to Haskell - Lecture 4</title>

    <meta name="description" content="A course on the world's fastest growing functional programming language">
    <meta name="author" content="Nishant Shukla">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />


    <link rel="stylesheet" href="css/bootstrap.css">
    <link rel="stylesheet" href="css/bootstrap-responsive.min.css">
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/serif.css" id="theme">
    <link href='http://fonts.googleapis.com/css?family=Ubuntu' rel='stylesheet' type='text/css'>

    <style>
      body {
      padding-top: 30px;
      padding-bottom: 40px;
      }
    </style>

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/pojoaque.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <script src="js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>

  </head>


  <body>

    <script src="nav.js"></script>    

    <script>
      function toggleElements(one, two) {
          document.getElementById(one).style.display = 'none';
          document.getElementById(two).style.display = 'block';
      }
    </script>


    <div class="reveal">

      <!-- Slides begin here! -->
      <div class="slides">
	<section>


          <section>
            <h1>Introduction To Haskell</h1>
            <p>Lecture 4</p>
            <p>
              <br>
            </p>
            <p>#SyntaxSwag</p>
	  </section>

	  <section>
	    <h3>Using These Slides</h3>
	      <h4>Every slide has a secret note.</h4>
	      <small>
	      <ul>
		<li>On <b>Chrome</b>: press <code>F12</code>, then click <b>Console</b></li>
		<li>On <b>IE</b>: press <code>F12</code>, then click <b>Console</b></li>
		<li>On <b>Firefox</b>: <code>Ctrl+Shift+k</code></li>
	      </ul>
	      </small>
	      <br>
	      <br>
	      <p><h3>Shortcut Keys:</h3></p>
	    <center>
	      <table width="80%">
		<tr>
		  <td><code>↓</code>, <code>PgDn</code>, <code>n</code>, <code>j</code></td>
		  <td>next slide</td>
		</tr>
		<tr>
		  <td><code>↑</code>, <code>PgUp</code>, <code>p</code>, <code>k</code></td>
		  <td>prev slide</td>
		</tr>
		<tr>
		  <td><code>Esc</code></td>
		  <td>enables <code>ctrl+f</code> globally</td>
		</tr>
	      </table>
	    </center>

	    <aside class="notes">Hi there! This is a secret lecture note. Every slide has a little blurb of text like this!</aside>
	  </section>


	  <section>
	    <h2>Review</h2>
	    
	    <table style="width:100%">
	      <tr>
		<td>
		  <center>
		    <p>Haskell is</p>
		    <ul>
		      <li>Purely functional</li>
		      <li>Statically typed</li>
		      <li>Lazy</li>
		    </ul>
		  </center>
		</td>
		<td class="fragment roll-in">
		  <center>
		    <p>Data looks like</p>
		    <ul>
		      <li>Bool</li>
		      <li>Int</li>
		      <li>Char</li>
		      <li>...</li>
		    </ul>
		  </center>
		</td>
	      </tr>
	    </table>
	    
	    <br>
	    <div class="fragment roll-in">
	      <p>Lists and Tuples are useful data structures</p>
	      <table style="width:100%">
		<tr>
		  <td>
		    <center>
		      <p>List</p>
		      <code>[1,2,3]</code>
		    </center>
		  </td>
		  <td>
		    <center>
		      <p>Tuple</p>
		      <code>(1, "one")</code>
		    </center>
		  </td>
		</tr>
	      </table>
	    </div>

	    <aside class="notes">Just as a reminder, there are the basic properties of Haskell.</aside>

	  </section>

	  <section>
	    <h3>More Review</h3>
	    <p>Everything in Haskell has a Type</p>
	    <small>Here are some Type declarations.</small>
	    <small><p>These are your <b>greatest weapons</b>.</p></small>
	    <pre><code class="haskell">
head :: [a] -> a -- gets the first element of a list

tail :: [a] -> [a] -- gets everything but the first element

last :: [a] -> a -- gets the last element of a list

init :: [a] -> [a] -- gets everything but the last element

(++) :: [a] -> [a] -> [a] -- concatenates two lists together

(:) :: a -> [a] -> [a] -- prepends an element to a list

fst  :: (a,b) -> a -- gets the first element of a tuple

snd  :: (a,b) -> b -- gets the second element of a tuple
	    </code></pre>

	    <aside class="notes">These are the most fundamental and important functions that are used everywhere.</aside>
	  </section>

	  <script>
	    function clearAll() {
            document.getElementById('cipherA').style.display = 'none';
            document.getElementById('cipherB').style.display = 'none';
            document.getElementById('cipherC').style.display = 'none';
            document.getElementById('cipherD').style.display = 'none';
	    }
	    function showOne(cipher) {
	    clearAll();
	    document.getElementById(cipher).style.display = 'block';
	    }
	  </script>
	  
	  
	  <section>
	    <h3>Review of Homework 3</h3>
	    <small><a href="lec03.html#/0/21" target="_blank">Implement a Caesar Cipher</a></small>
	    <table style="width:100%">
	      <tr>
		<td><center><a onclick="showOne('cipherA');">A</a></center></td>
		<td><center><a onclick="showOne('cipherB');">B</a></center></td>
		<td><center><a onclick="showOne('cipherC');">C</a></center></td>
		<td><center><a onclick="showOne('cipherD');">D</a></center></td>
	      </tr>
	    </table>
	    
	    <pre id='cipherA'><code class='haskell'>
-- This example uses 'succ' to get next letter

cipher :: String -> Int-> String
cipher "" n = ""
cipher str n = rotate (head str) n : cipher (tail str) n

rotate :: Char -> Int -> Char
rotate c 0 = c
rotate c n = rotate (next c) (n-1)

next :: Char -> Char
next c = if c=='z' then 'a' else succ c
	    </code></pre>

	    <pre id='cipherB' style="display:none;"><code class='haskell'>
-- Importing a really useful library
-- designed by Preetam C. Jinka

import Data.Char

cipher :: [Char] -> Int -> [Char]
cipher [] _ = []
cipher (s:ss) n = (rotate s n) : (cipher ss n)

rotate :: Char -> Int -> Char
rotate c 0 = c
rotate c n = int2letter ( mod ((letter2int c) + n) 26 )

letter2int c = ord c - 97
int2letter n = chr (n + 97)
	    </code></pre>

	    <pre id='cipherC' style="display:none;"><code class='haskell'>
-- Here's a one-line solution 
-- designed by James C. Sun

import Data.Char
cipher :: [Char] -> Int -> [Char]
cipher s n = map (\c -> ([c..'z'] ++ ['a'..c]) !! mod n 26) s		
	    </code></pre>

	    <pre id='cipherD' style="display:none;"><code>
-- designed by Matthias pall Gissurarson

import Data.List
import Data.Maybe

alphabet:: [Char]
alphabet = cycle ['a'..'z']

rotate:: Int -> Char -> Char
rotate k a = alphabet !! (k + ( fromJust ( elemIndex a alphabet)))

cipher:: [Char] -> Int -> [Char]
cipher str k = map (rotate k) str		
	    </code></pre>

	    <aside class="notes">This was one of the hardest homework assignements. It was to really get your hands dirty in Haskell. I hope these examples clear up some confusion about where to start.</aside>
	  </section>

	  <!-- Maybe include Lambda Calculus now? -->

	  <section>
	    <h2>Pattern Matching</h2>
	    <p>A function can have multiple patterns</p>
	    <p>Almost like overloading methods in Java or C++</p>
	    <pre><code class="haskell">
guess :: Int -> [Char]
guess 42 = "correct!"
guess x  = "wrong guess!"
	    </code></pre>
	    <p class="fragment roll-in">Each pattern has the same type deceleration</p>

            <aside class="notes">Patterns are matched top-down.</aside>
	  </section>

          <section>
	    <h4>Pattern Matching</h4>
	    <ul>
	      <li><p>Patterns are matched in order, top-down</p></li>
	      <li><p>Only the first matched pattern is evaluated</p></li>
	      <li><p>The patterns must exhaust the entire domain</p></li>
	    </ul>

	    <aside class="notes">The last point is very important. Always make sure your patterns match the entire set of inputs.</aside>
	  </section>

	  <section data-state="soothe">
	    <h3>What's wrong with this code?</h3>
	    <pre><code class="haskell">
fib :: Int -> Int
fib n = fib(n-1) + fib(n-2)
fib 0 = 1
fib 1 = 1
	    </code></pre>
	    <div class="fragment roll-in">
	      <p>The base case is never hit.</p>
	      <p>The first pattern eats up everything!</p>
	      <strong>∞ loop</strong>
	      <p><img src="L04_files/woahcool.gif"></p>
	    </div>

	    <aside class="notes">Remember, patterns are matched top-down. So the base case is never hit in this example.</aside>
	  </section>

	  <section>
	    <h3>More Pattern Matching</h3>
	    <br>
	    <p>You can even match lists using Construct</p>
	    <pre><code class='haskell'>
head (firstItem : everythingElse) = firstItem
	    </code></pre>
	    <pre><code class='haskell'>
tail (x:xs) = xs
	    </code></pre>

	    <aside class="notes">Using constructs in pattern matching makes your code look really elegant.</aside>

	  </section>

	  <section data-state="soothe">
	    <h3>More Pattern Matching</h3>
	    <p>White a function to detect if a list is a palindrome</p>
	    <pre id="c"><code class="haskell">
isPal :: Eq a => [a] -> Bool



	    </code></pre>
	    <pre id="d" style="display:none;"><code class="haskell">
isPal        :: Eq a => [a] -> Bool
isPal [x]    = True
isPal [x,y]  = x == y
isPal (x:xs) = (x == (last xs)) && isPal (init xs)
	    </code></pre>
	    <span style="font-size:12px;">
	      <a onclick="toggleElements('d', 'c');">(clear answer)</a>
	      <a onclick="toggleElements('c', 'd');">(show answer)</a>
	    </span>

	    <aside class="notes">We can use pattern matching in designing a function to detect palindromes.</aside>
	  </section>


	  <section data-state="soothe">
	    <h3>Pattern matching is powerful</h3>
	    <p>We can define <code class="haskell">fst</code> with pattern matching</p>
	    <pre><code class="haskell">
fst :: (a,b) -> a
fst (x,y) = x
	    </code></pre>
	    <br>
	    <div class="fragment roll-in">
	      <p>Try defining <code class="haskell">head</code> with pattern matching</p>
	      <pre id="a"><code class="haskell" contenteditable>
head :: [a] -> a



	      </pre></code>
	      <pre id="b" style="display:none;"><code class="haskell">
head :: [a] -> a
head (x:xs) = x
head [x] = x
head [] = error "empty list"
	      </code></pre>
	      <span style="font-size:12px;">
		<a onclick="toggleElements('b', 'a');">(clear answer)</a>
		<a onclick="toggleElements('a', 'b');">(show answer)</a>
	      </span>
	    </div>

	    <aside class="notes">Pattern matching makes code look more readable.</aside>
	  </section>

	  
	  <section>
	    <h3>Wildcard in Pattern Matching</h3>
	    <ul>
	    <li><p>We can specify when a value is unused.</p></li>
	    <li><p>The "_" symbol is called a wildcard in Haskell.</p></li>
	    <li><p>This is how it's used:</p></li>
	    <pre><code class="haskell">
head (x:_)  = x

tail (_:xs) = xs
	    </code></pre>
	    </ul>
	    
	    <aside class="notes">Using a wildcard is optional. Use it for readability.</aside>
	  </section>

	  <section>
	    <h3>Error Handling</h3>
	    <p>When GHCi is angry, it produces error messages through the <code class="haskell">error</code> function.</p>
	    <pre><code class="haskell">
error :: [Char] -> a
	    </code></pre>
	    <br>
	    <p>The official implementation of <code class="haskell">head</code> is</p>
	    <pre><code class="haskell">
head             :: [a] -> a
head (x:_)       =  x
head []          =  error "Prelude.head: empty list"
	    </code></pre>
	    <p><a target="_blank" href="http://www.haskell.org/onlinereport/standard-prelude.html">*</a></p>

	    <aside class="notes">Try it out. In GHCi, type `error "oh no!"`</aside>
	  </section>

	  <section>
	    <h2>Guards</h2>
	    <ul>
	      <li><p>Guards are clean <code class="haskell">if</code> statements.</p></li>
	      <li><p>Just like with pattern matching, order matters.</p></li>
	      <li><p>A guard is introduced by the <code class="haskell">|</code> symbol.</p></li>
	      <li><p>And it's followed by a Bool expression.</p></li>
	      <li><p>Then followed by the function body</p></li>
	      <pre><code class="haskell">
guessMyNumber x
            | x > 27    = "Too high!"
            | x < 27    = "Too low!"
            | otherwise = "Correct!"
	      </code></pre>
	      <small><code class="haskell">otherwise</code> is just a fancy word for <code class="haskell">True</code></small>
	    </ul>

	    <aside class="notes">Guards are just pretty if-statements.</aside>
	  </section>

	  <section>
	    <h3>Guards</h3>
	    <p>Guards are very powerful.</p>
	    <p>Anything done with pattern matching can be done with guards.</p>
	    <pre><code class="haskell">
head' :: [a] -> a
head' xs
    | null xs   = error "list is empty"
    | otherwise = xs !! 0
	      </code></pre>
	      <small class="fragment roll-in"><code>!!</code> is a function that gives an element at an index</small>
	      
	      <aside class="notes">Here I've introduced a function (!!) that returns the element at a specific index. I'm using (!!) in-fix in this example.</aside>
	  </section>

	  <section>
	    <h3>Variables</h3>
	    <p>These are not like your typical Java variables</p>
	    <p><small>In Java or C++, you can redefine variables:</small></p>
	    <pre><code class="haskell">
x = 1;

...

x = 2;
	    </code></pre>
	    <br>
	    <p>Mathematically, this makes no sense.</p>

	    <aside class="notes">Haskell is very different. It is mathematical.</aside>

	  </section>

	  <section>
	    <h2>It implies <code class="haskell">1=2</code> Preposterous!</h2>
	    <img src="L04_files/noway.gif">

	    <aside class="notes">By the transitive property, the previous code implies 1=2.</aside>
	  </section>

	  <section>
	    <h2>Variables</h2>
	    <p>Haskell variables are immutable.</p>
	    <p>Once defined, they can't change.</p>
	    <br>
	    <p>They can be used with the <code class="haskell">let</code> keyword.</p>
	    <pre><code class="haskell">
slope (x1,y1) (x2,y2) = let dy = y2-y1
                            dx = x2-x1
                        in dy/dx
	    </code></pre>
	    <br>
	    <p>Or with the <code class="haskell">where</code> keyword.<p>
	    <pre><code class="haskell">
slope (x1,y1) (x2,y2) = dy/dx
                        where dy = y2-y1
                              dx = x2-x1
	    </code></pre>

	    <aside class="notes">They're called variables, but they do not change. They are always immutable.</aside>
	  </section>

	  <section>
	    <h2>Whitespace</h2>
	    <p>In Haskell, indentation matters.</p>
	    <q>Code which is part of some expression should be indented further in than the beginning of that expression</q><a href="http://en.wikibooks.org/wiki/Haskell/Indentation"> *</a>
	    <pre><code class="haskell">
Level-1
    Level-2
              Level-3
              Level-3
              Level-3
    Level-2
     Level-3
     Level-3

Level-1
 Level-2
 Level-2

Level-1
	    </code></pre>
	    <small>Don't use tab. Use spaces '<code class="haskell"> </code>'.</small>

	    <aside class="notes">Indentation matters!</aside>
	  </section>



          <section>
	    <h1>Homework</h1>
	    <h2>A Useful Tool</h2>
	    <ol>
	      <li><a href="https://docs.google.com/forms/d/1nOtIyac9Mf6LsOVtXO0dpUKvMhPB6lx6DubvpnDn-RE/viewform">Fill out this week's form.</a></li>
	      <li>
		<p>Convert between metric and imperial.</p>
		<p><small><code class="haskell">convert :: (Double, [Char]) -> (Double, [Char])</code></small></p>
		<small>
		<ul>
		  <li> m ↔ yd</li>
		  <li> L  ↔  gal </li>
		  <li> kg  ↔  lb </li>
		</ul>
		</small>
		<pre><code class="haskell">
Prelude> convert (1, "m")
(1.09361, "yd")
Prelude> convert (1, "L")
(0.264172, "gal")
Prelude> convert (1, "kg")
(2.20462, "lb")
		</code></pre>
	      </li>

	    </ol>

	    <aside class="notes">This is easier than it looks.</aside>

	  </section>

	</section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,
      mouseWheel: true,
      rollingLinks: false,

      theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
      transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

      // Optional libraries used to extend on reveal.js
      dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
      // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
      ]
      });

    </script>


    <script>window.jQuery || document.write('<script src="js/vendor/jquery-1.8.3.min.js"><\/script>')</script>
    <script src="js/vendor/bootstrap.min.js"></script>

    <script src="js/main.js"></script>

    <script>
      Reveal.addEventListener( 'slidechanged', function( event ) {
      // event.previousSlide, event.currentSlide, event.indexh, event.indexv
      var notes = event.currentSlide.querySelector(".notes");
      if(notes) {
          console.info("---");
          console.info(notes.innerHTML.replace(/\n\s+/g,'\n'));
      }
      } );
    </script>


    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-29747714-1']);
      _gaq.push(['_trackPageview']);

      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>


  </body>
</html>
