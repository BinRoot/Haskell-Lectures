<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Introduction to Haskell - Lecture 12</title>

    <meta name="description" content="A course on the world's fastest growing functional programming language">
    <meta name="author" content="Nishant Shukla">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <link rel="stylesheet" href="css/bootstrap.css">
    <link rel="stylesheet" href="css/bootstrap-responsive.min.css">
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/serif.css" id="theme">
    <link href='http://fonts.googleapis.com/css?family=Ubuntu' rel='stylesheet' type='text/css'>

    <style>
      body {
      padding-top: 30px;
      padding-bottom: 40px;
      }
    </style>

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/pojoaque.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <script src="js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>

  </head>


  <body>

    <script src="nav.js"></script>

    <script>
      function toggleElements(one, two) {
          document.getElementById(one).style.display = 'none';
          document.getElementById(two).style.display = 'block';
      }
    </script>


    <div class="reveal">

      <!-- Slides begin here! -->
      <div class="slides">
	<section>

          <section>
            <h1>Introduction To Haskell</h1>
            <p>Lecture 12</p>
            <p>
              <br>
            </p>
            <p>Category Theory</p>
	    <br>
	    <p><i><a href="https://twitter.com/superninjarobot/status/321663231842189312" target="_blank">Proposed title</a>:</i> Do You Even <a href="http://en.wikipedia.org/wiki/Lift_(mathematics)" target="_blank">Lift</a>?</p>
	  </section>

	  <section>
	      <h2>Category Theory</h2>
	      <a href="http://yogsototh.github.io/Category-Theory-Presentation/#slide-2" target="_blank"> Not really about Cat and Glory
	      <img src="L12_files/categlory.jpg">
	      </a>
	  </section>

	  <section>
	      <small><q>...allows one to see the <b>forest</b> rather than the <b>individual trees</b>, and offers the possibility for study of the structure of the <b>entire forest</b>, in preparation for the next stage of abstraction - <b>comparing forests</b>.</q></small>
	      <p><small><a href="http://www.amazon.com/Category-theory-introduction-advanced-mathematics/dp/B0006D0EXY" target="_blank">-- Herrlich, Strecker, <b>Category Theory</b></a></small></p>
	      <img src="L12_files/forest.jpg">
	  </section>

	  <section>
	      <h3>Terminology</h3>

	      <a href="http://yogsototh.github.io/Category-Theory-Presentation/#slide-7" target="_blank"><img src="L12_files/terms.png"></a>
	  </section>

	  <section>
	      <h3>History</h3>
	      <p>Roots in <b>algebraic topology</b> in the early 1940s by Eilenberg and Mac Lane</p>
<object width="560" height="315"><param name="movie" value="http://www.youtube.com/v/kdpbfOzkJzI?start=409&end=582&version=3&amp;hl=en_US"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/kdpbfOzkJzI?start=409&end=582&version=3&amp;hl=en_US" type="application/x-shockwave-flash" width="560" height="315" allowscriptaccess="always" allowfullscreen="true"></embed></object>
<!--	      <iframe width="560" height="315" src="http://www.youtube.com/embed/kdpbfOzkJzI?start=409&end=582" frameborder="0" allowfullscreen></iframe> -->
	  </section>

	  <section>
	      <h3>Why Category Theory?</h3>
	      <p>It provides a <b>powerful language</b>.</p>
	      <br>
	      <p>It can <b>translate</b> difficult problems to easy ones.</p>
	      <br>
	      <p>It features strong <b>abstractions</b> and attempts to unify separate ideas.</p>
	      <p></p>
	  </section>

	  <section>
	      <h3>Brouwer Fixed-Point Theorem</h3>
	      <small>Category Theory in Action</small>
	      <p><b>A continuous function from a unit circle to itself must have a fixed point.</b></p>
	      <p><a href="http://investigations1213.blogspot.com/2012/11/brouwers-fixed-point-theorem-proof-in_13.html" target="_blank"><img src="L12_files/brouwer.gif"></a></p>
	      <p><small>(Image © <a href="http://investigations1213.blogspot.com/2012/11/brouwers-fixed-point-theorem-proof-in_13.html" target="_blank">Jack E.</a>)</small></p>
	  </section>

	  <section>
	      <h3>Implications of Brouwer's Theorem</h3>
	      <small>
	      <ul>
		  <li><p>If you crumple up one sheet of paper and place it on top of a flat sheet, then at least one point will be directly over it's corresponding point.</p></li>
		  <li><p>After sloshing around a cup of coffee, at least one point will always remain in the same spot.</p></li>
		  <li><p>Brouwer's Theorem assures existence of solutions to some differential equations.</p></li>
		  <li><p>Brouwer's Theorem assures existence of equilibria in Game Theory.</p></li>
	      </ul>
	      </small>

	      <center>
	      <table>
		  <tr>
		      <td width="25%">
			  <img style="width:150px; height:150px" src="L12_files/paper.png">
		      </td>
		      <td width="25%">
			  <img style="width:150px; height:150px" src="L12_files/coffee.png">
		      </td>
		      <td width="25%">
			  <img style="width:150px; height:150px" src="L12_files/diffyeq.gif">
		      </td>
		      <td width="25%">
			  <img style="width:150px; height:150px" src="L12_files/gametheory.png">
		      </td>

		  </tr>
	      </table>
	      </center>

	  </section>

	  <section>
	      <h3>Proof (Step 1)</h3>

	      <p>Let <b>D</b> be the unit-circle disk.</p>
	      <p>Let <b>S</b> be the surface of the unit-circle.</p>
	      <br>
	      <p><u>Lemma</u>: There is no continuous function</p><p> <i>h: D → S</i> that leaves each point on S fixed.</p>
	      <br>
	      <center><img src="L12_files/cat_top.png"></center>

	  </section>

	  <section>
	      <h3>Proof of Lemma (Step 2)</h3>
		      <p>Using a Functor, we can transform one Category to another by preserving identities and compositions.</p>
		      <br>
		      <center>
		      <table>
			  <tr>
			      <td width="48%">
				  <center>
				      Topologies
				  </center>
			      </td>
			      <td width="4%">
				  <center>
				      →
				  </center>
			      </td>
			      <td width="48%">
				  <center>
				      Groups
				  </center>
			      </td>
			  </tr>

			  <tr>
			      <td>
				  <center>
				      <img src="L12_files/cat_top.png">
				  </center>
			      </td>
			      <td>

			      </td>
			      <td>
				  <center>
				      <img src="L12_files/cat_gro.png">
				  </center>
			      </td>

			  </tr>
		      </table>
		      </center>

	  </section>

	  <section>
	      <h3>Proof of Lemma (Step 3)</h3>
	      <img src="L12_files/cat_gro.png">
	      <p>By instead examining the Category of Groups, we can conclude that no such group homomorphism <i>g: 0 → Z</i> can exist.</p>

	      <br>
	      
	      <p class="fragment roll-in">We have proved the Lemma.</p>

	  </section>

	  <section data-state="soothe">
	      <h3>Proof (The Build Up)</h3>
	      
	      <p><b>GIVEN: </b><u>Lemma</u>: There is no continuous function</p><p> <i>F: D → S</i> that leaves each point on S fixed.</p>
	      <br>
	      <p><b>SHOW</b>: A continuous function <i>f: D → D</i> must have a fixed point</p>

	      <br>
	      <small>Take a moment, and try this by yourself.</small>
	  </section>

	  <section>
	      <h3>Proof (Fin)</h3>
	      <p><small>...and now, THE DROP!</small></p>
	      <p>By way of contradiction, assume ∀x∈D: x ≠ f(x)</p>
	      <img src="L12_files/proof.png">
	      <p>Then we can always form the function <i>F: D → S</i> that leaves each point on S fixed.</p>
	      <p>Contradiction. GG.</p>
	  </section>

	  <section>
	      <h3>Definition: Category</h3>
	      <small class="fragment roll-in"><p>A <b>Category</b> <i>C</i> is a collection of <b>Ob(<i>C</i>)</b> and <b>Ar(<i>C</i></b>).</p></small>
	      <p><img src="L12_files/category.png"></p>
	      <small class="fragment roll-in"><b>Ob(<i>C</i>)</b> are the objects of <b><i>C</i></b>. &nbsp;<b>Ar(<i>C</i>)</b> are the "arrows" or morphisms of <b><i>C</i></b>.</small>
	      <small class="fragment roll-in"><p>Each <i><b>f</b>:A→B</i> ∈ <b>Ar(<i>C</i>)</b> has it's <b>A</b> and <b>B</b> chosen from <b>Ob(<i>C</i>)</b>.</p></small>
	      <small class="fragment roll-in">If <b><i>f</i></b>:A→B and <b><i>g</i></b>:B→C, then there always exists <b><i>h</i></b> = <b><i>g∘f</i></b>: A→C</small>
	      <small class="fragment roll-in">For every <b>A</b> ∈ <b>Ob(<i>C</i>)</b>, there is an identity function <b>id<sub>A</sub></b>: A→A.</id></small>

	  </section>
          <section>
	      <h2>Axioms</h2>
	      <p><small>Left and right identity: <b><i>f</i>∘id<sub>A</sub></b> = <b>id<sub>A</sub>∘<i>f</i></b></small></p>
	      <div class="fragment roll-in">
		  <p><small>Associativity: <b><i>h</i>∘(<i>g∘f</i>)</b> = <b>(<i>h∘g</i>)∘<i>f</i></b></small></p>
		  <p><img style="width:500px;" src="L12_files/categoryexample.png"></p>
	      </div>

	      
	  </section>

	  <section data-state="soothe">
	      <h1><a href="http://yogsototh.github.io/Category-Theory-Presentation/#slide-16" target="_blank">Question Time!</a></h1>
	  </section>

          <section>
	      <h3>Examples of Categories</h3>
	      <ul>
		  <li><b><a href="http://en.wikipedia.org/wiki/Set_theory" target="_blank">Set</a></b> (with set functions)</li>
		  <li><b><a href="http://shuklan.com/haskell/lec09.html#/0/9" target="_blank">Monoids</a></b> are one-object categories</li>
		  <li><b><a href="http://simple.wikipedia.org/wiki/Group_theory" target="_blank">Grp</a></b> (groups with group morphisms)</li>
		  <li><b><a href="http://en.wikipedia.org/wiki/Ring_theory" target="_blank">Rng</a></b> (rings with ring morphisms)</li>
		  <li><b><a href="http://www.haskell.org/haskellwiki/Hask">Hask</a></b> (Haskell types and functions)</li>
	      </ul>
	  </section>

	  <section>
	      <h2>Hask</h2>
	      <p><b>Ob(<i>Hask</i>)</b> = the Haskell types. (Bool, [Char], ...)</p>
	      <p><b>Ar(<i>Hask</i>)</b> = the Haskell functions. (head, not, ...)</p>
	      <p>The identity function is <code>id :: a -> a</code></p>
	      <br>
	      <p>The axioms are satisfied</p>
	      <p><small>Left and right identity: <b><i>f</i>∘id</b> = <b>id∘<i>f</i></b></small></p>
	      <p><small>Associativity: <b><i>h</i>∘(<i>g∘f</i>)</b> = <b>(<i>h∘g</i>)∘<i>f</i></b></small></p>

	  </section>

	  <section>
	      <h2>Functor</h2>
	      <small><p>Functor <b>F</b>: C→D is a transformation from Category <b><i>C</i></b> to Category <b><i>D</i></b></p></small>
	      <a target="_blank" href="http://en.wikibooks.org/wiki/Haskell/Category_theory#Functors"><img src="L12_files/functor.png"></a>
	      <small>It maps objects in C to objects in D, and functions in C to functions in D</small>

	      <br>
	      <p>Functor Axioms:</p>
	      <small>
	      <ol>
		  <p><li>F(id<sub>A</sub>) = id<sub>F(A)</sub></li></p>
		  <p><li>F(f∘g) = F(f)∘F(g)</li></p>
	      </ol>
	      </small>

	  </section>

	  <section>
	      <h3>Functors in Haskell</h3>
	      <p>In Haskell, a Functor is a typeclass for things that can be mapped over.</p>
	      <pre><code class="haskell">
Prelude> fmap odd (Just 3)    -- Maybe is a Functor
Just True
	      </code></pre>
	      <pre><code class="haskell">
Prelude> fmap odd [1..5]      -- a list is a Functor
[True,False,True,False,True]
	      </code></pre>

	      

	  </section>
	  
	  <section>
	      <h3><code>Maybe</code> Functor</h3>

	      <small><p>1. The <i>type constructor</i> transforms anything of type <code>a</code> to <code>Maybe a</code></p></small>
	      <small><p>Like transforming an object in <b><i>C</i></b> to an object in <b><i>D</i></b>.</p></small>
	      

	      <p><code>Maybe</code> derives the <code>Functor</code> typeclass as follows:</p>
	      <pre><code>
instance Functor Maybe where
  fmap f (Just x) = Just (f x)
  fmap _ Nothing  = Nothing
	      </code></pre>
	      
	      <br>
	      <small><p>2. fmap transforms a function <b><i>f</i></b>: a→b</p> to Maybe a → Maybe b.</small>

	  </section>

	  <section>
	      <h3><code>Maybe</code> Functor (Cont.)</h3>
	      <p>We just showed that Maybe transforms objects and functions over from the <b>Hask</b> category to the <b>Maybe</b> subcategory.</p>
	      <br>
	      <p>The Functor Axioms are satisfied:</p>
	      <ol>
		  <p><li>fmap id = id</li></p>
		  <p><li>fmap (f . g) = fmap f . fmap g</li></p>
	      </ol>
	      
	  </section>

	  <section>
	      <h2>Monads</h2>
	      <p>A Monad is a functor from a Category to itself: <b>M: C→C</b></p>

	      <small>
		  <p>And, for every <b>X</b> ∈ Ob(<b><i>C</i></b>)</p>
	      <ul>
		  <li><p>unit: <b>X</b>→M(<b>X</b>)</p></li>
		  <li><p>join: M(M(<b>X</b>))→M(<b>X</b>)</p></li>
	      </ul>
	      </small>
	      <pre><code class="haskell">
class Functor m => Monad m where
  return :: a -> m a
  (>>=)  :: m a -> (a -> m b) -> m b
	      </code></pre>
	      <pre><code>
Prelude> import Control.Monad
Prelude Control.Monad> :t join
join :: Monad m => m (m a) -> m a
	      </code></pre>
	  </section>

	  <section>
	      <h2><a href="http://en.wikibooks.org/wiki/Haskell/Category_theory#Monads" target="_blank">The Monad Laws</a></h2>
	      <ol>
		  <li>
		      <p><i>join</i> ∘ M(<i>join</i>) = <i>join</i> ∘ <i>join</i></p>
		      <small><q>Collapsing the inner two layers first, then that with the outer layer is exactly the same as collapsing the outer layers first, then that with the innermost layer.</q></small>
		  </li>
		  <br>
		  <li>
		      <p><i>join</i> ∘ M(<i>unit</i>) = <i>join</i> ∘ <i>unit</i> = <i>id</i></p>
		      <small><q>Applying return to a monadic value, then joining the result should have the same effect whether you perform the return from inside the top layer or from outside it.</q></small>
		  </li>
		  <br>
		  <li><i>unit</i> ∘ <i>f</i> = M(<i>f</i>) ∘ <i>unit</i></li>
		  <br>
		  <li><i>join</i> ∘ M(M(<i>f</i>)) = M(<i>f</i>) ∘ <i>join</i></li>
	      </ol>
	  </section>

	  <section>
	      <h3>The Power of Abstraction</h3>
	      <p>Category theory powers Haskell's generalizability.</p>
	      <ul>
		  <li><a href="http://shuklan.com/haskell/lec09.html#/0/5" target="_blank">Functors generalize maps</a></li>
		  <li><a href="http://yogsototh.github.io/Category-Theory-Presentation/#slide-77" target="_blank">Catamorphisms generalize folds</a></li>
	      </ul>
	  </section>

	  <section>
	      <h2>Thanks for your time!</h2>
	      <img src="L12_files/cat.gif"</img>
	      <p>Homework: <a href="https://docs.google.com/a/virginia.edu/forms/d/16H3j_LdorJ4wAgRZRchGD0PGXTaYOIwXAfJwL4grRtM/viewform" target="_blank">Fill out the Course Evaluation</a></p>
	      
	  </section>

	</section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,
      mouseWheel: true,
      rollingLinks: false,

      theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
      transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

      // Optional libraries used to extend on reveal.js
      dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
      // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
      ]
      });

    </script>

    <script>window.jQuery || document.write('<script src="js/vendor/jquery-1.8.3.min.js"><\/script>')</script>
    <script src="js/vendor/bootstrap.min.js"></script>

    <script src="js/main.js"></script>

    <script>
      Reveal.addEventListener( 'slidechanged', function( event ) {
      // event.previousSlide, event.currentSlide, event.indexh, event.indexv
      var notes = event.currentSlide.querySelector(".notes");
      if(notes) {
          console.info("---");
          console.info(notes.innerHTML.replace(/\n\s+/g,'\n'));
      }
      } );
    </script>


    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-29747714-1']);
      _gaq.push(['_trackPageview']);

      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>


  </body>
</html>
